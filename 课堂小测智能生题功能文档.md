# 课堂小测智能生题功能实现文档

## 目录

1. [功能概述](#功能概述)
2. [系统架构](#系统架构)
3. [实现原理](#实现原理)
4. [接口定义](#接口定义)
5. [数据库结构](#数据库结构)
6. [前端调用示例](#前端调用示例)
7. [后端实现详情](#后端实现详情)
8. [实现步骤](#实现步骤)
9. [注意事项](#注意事项)

## 功能概述

课堂小测智能生题功能是一个基于大语言模型的题目自动生成工具，可以根据用户输入的中文/英文内容描述，自动生成符合中华文化特色的教学题目，支持多种题型（单选题、多选题、简答题、讨论题）以及中英文双语输出。该功能特别适用于教师快速生成课堂测验题目，提高教学效率。

## 系统架构

整体架构基于前后端分离模式：
- **前端**：基于Vue框架实现的课堂小测界面，位于`app/work`目录
- **后端**：基于NestJS框架的题目生成服务，位于`app/server`目录
- **AI服务**：通过调用大语言模型（如GPT）进行内容生成
- **数据库**：使用MySQL存储生成的题目及其相关信息

系统组件交互流程：
```
用户界面 -> 前端组件 -> 后端API -> AI服务 -> 后端处理 -> 前端展示 -> 数据库存储
```

## 实现原理

智能生题功能主要通过以下流程实现：

1. 用户在前端输入描述内容并选择题目类型和语言
2. 前端将请求发送至后端`chatTopic`接口
3. 后端构造包含系统提示词的请求，提示词中包含特定的题型模板和格式要求
4. 后端将请求转发给大语言模型API
5. 大语言模型根据提示词和用户输入生成符合特定格式的题目
6. 后端处理AI返回的内容并通过流式响应返回给前端
7. 前端接收并展示生成的题目，用户可以进行修改和保存
8. 保存后的题目将存入数据库，可用于实际教学测验

## 接口定义

### 前端到后端接口

**请求接口**: `/chatgpt/chat-topic`

**请求方法**: POST

**请求参数**:
```typescript
{
  appId: number;   // 题型类型 (1-单选, 2-多选, 3-简答, 4-讨论题)
  prompt: string;  // 用户输入的内容描述
  ln: number;      // 语言 (1-中文, 2-英文)
}
```

**响应结构**:
```typescript
{
  text: string;    // 生成的题目内容（流式返回）
}
```

### 内部AI接口调用

后端使用自定义提示词调用大语言模型API：

**系统提示词模板**:
```
您是中华文化大师，请根据我的内容进行优化、生成相关一个中国文化相关题型，尽量做的精细，不管我问你什么、都需要您回复我一个内容相关的题型出来，并且按规则输出，除了题型之外、不要无关内容和总结。我需要的题型规则是：{题型模板}。{语言选择}
```

**用户提示词模板**:
```
我的中国文化内容是：{用户输入内容}
```

## 数据库结构

课堂小测功能主要涉及以下数据表：

### course_question表

| 字段名      | 类型         | 说明           |
|------------|--------------|---------------|
| id         | int          | 主键ID         |
| courseUqId | varchar(36)  | 课程唯一标识    |
| title      | varchar(255) | 题目标题       |
| content    | text         | 题目内容       |
| type       | int          | 题目类型：1-单选, 2-多选, 3-简答, 4-讨论题 |
| answer     | text         | 题目答案       |
| desc       | text         | 题目解析       |
| sort       | int          | 排序           |
| userId     | int          | 创建用户ID     |
| status     | int          | 状态           |

## 前端调用示例

### 组件引用和初始化

```javascript
// 在Vue组件中引入相关依赖
import { ref, watch } from 'vue';
import { useMessage } from 'naive-ui';

// 状态定义
const loading = ref(false);
const version = ref(1);  // 题型：1-单选, 2-多选, 3-简答, 4-讨论题
const ln = ref(1);       // 语言：1-中文, 2-英文
const topicPrompt = ref(''); // 用户输入内容
const topicValue = ref(''); // 生成的题目内容
const message = useMessage();

// 题型选项
const versionOptions = [
  { label: "单选", value: 1 },
  { label: "多选", value: 2 },
  { label: "简答", value: 3 },
  { label: "讨论题", value: 4 }
];

// 语言选项
const lnOptions = [
  { label: "中文题", value: 1 },
  { label: "英文题", value: 2 }
];
```

### 智能生题功能实现

```javascript
// 调用智能生题接口
async function chatTopic() {
  const initialData = "";
  let generatedData = "";
  loading.value = true;
  topicValue.value = "";
  
  try {
    await request({
      url: "/chatgpt/chat-topic",
      data: {
        appId: version.value,      // 题型类型
        prompt: topicPrompt.value, // 用户输入内容
        ln: ln.value               // 语言选择
      },
      onDownloadProgress: ({event}) => {
        // 处理流式响应
        const target = event.target;
        const {responseText} = target;
        const lastIndex = responseText.lastIndexOf("\n", responseText.length - 2);
        let text = responseText;
        if (lastIndex !== -1) {
          text = responseText.substring(lastIndex);
        }
        const response = JSON.parse(text);
        generatedData = initialData + (response.text ?? "");
        topicValue.value = generatedData;
      }
    });
    loading.value = false;
  } catch {
    loading.value = false;
  }
}

// 保存生成的题目
const saveTopic = () => {
  const content = topicValue.value;
  if (!content) {
    message.error("请先生成内容！");
    return;
  }
  
  // 触发保存事件，由父组件处理保存逻辑
  emit('saveTopic', {
    value: content,
    type: version.value
  });
};
```

### 前端HTML模板示例

```html
<template>
  <div class="prep-topic">
    <!-- 题型选择 -->
    <div class="option-row">
      <span class="label">题型</span>
      <div class="controls">
        <RadioGroup v-model:value="version" size="small">
          <RadioButton 
            v-for="opt in versionOptions" 
            :key="opt.value" 
            :value="opt.value" 
            :label="opt.label" 
          />
        </RadioGroup>
      </div>
    </div>
    
    <!-- 语言选择 -->
    <div class="option-row">
      <span class="label">语言</span>
      <div class="controls">
        <RadioGroup v-model:value="ln" size="small">
          <RadioButton 
            v-for="opt in lnOptions" 
            :key="opt.value" 
            :value="opt.value" 
            :label="opt.label" 
          />
        </RadioGroup>
      </div>
    </div>
    
    <!-- 输入区域 -->
    <div class="content-section">
      <NInput
        v-model:value="topicPrompt"
        type="textarea"
        :disabled="loading"
        :autosize="{ minRows: 10 }"
        placeholder="请输入您想要生成内容的简单描述、AI将为您输出一份完整题型!"
      />
      
      <!-- 预设标签 -->
      <div class="preset-tags">
        <NTag 
          v-for="preset in presetPrompts" 
          :key="preset.id"
          size="small"
          type="info"
          @click="topicPrompt = preset.prompt"
        >
          {{ preset.title }}
        </NTag>
      </div>
      
      <!-- 生成按钮 -->
      <div class="action-row">
        <NButton
          type="primary"
          size="small"
          style="width: 100%"
          :loading="loading"
          @click="chatTopic"
        >
          智能生成题型
        </NButton>
      </div>
    </div>
    
    <!-- 结果区域 -->
    <div class="section-title">
      <h4 class="font-bold">内容需求</h4>
    </div>
    
    <NInput
      v-model:value="topicValue"
      type="textarea"
      readonly
      :disabled="loading"
      :autosize="{ minRows: 10, maxRows: 16 }"
      placeholder=""
    />
    
    <!-- 保存按钮 -->
    <div class="action-row">
      <NButton
        type="primary"
        size="small"
        :disabled="loading"
        style="width: 100%"
        @click="saveTopic"
      >
        解析并提取
      </NButton>
    </div>
  </div>
</template>
```

## 后端实现详情

### 控制器方法实现 (chatTopic.controller.js)

```javascript
async chatTopic(chatProcessDto, req, res) {
  // 根据appId选择不同题型的提示词模板
  let promptTemplate = '';
  switch(chatProcessDto.appId) {
    default:
      promptTemplate = '单选题型，按固定规则回复，不要无关内容和帮助联系词，选项只需要四个A、B、C、D,我需要的规则是：\n题干: xxx\n选项:\nA: xxx\nB: xxx\nC: xxx\nD: xxx';
      break;
    case 2:
      promptTemplate = '多选题型，按固定规则回复，不要无关内容和帮助联系词，我需要的规则是：\n题干: xxx\n选项:\nA: xxx\nB: xxx\nC: xxx\nD: xxx\n答案: X,X,X\n解析: xxx';
      break;
    case 3:
      promptTemplate = '解答题，按固定规则回复，不要无关内容和帮助联系词。我需要的规则是：\n题干: xxx\n答案: xxx\n解析: xxx';
      break;
    case 4:
      promptTemplate = '讨论题，按固定规则回复，不要无关内容和帮助联系词。我需要的规则是：\n题干: xxx\n答案: xxx\n解析: xxx';
      break;
  }
  
  // 处理语言选择
  let languagePrompt = '';
  if (chatProcessDto.ln === 2) {
    languagePrompt = ',请生成英文题目，固定规则名称不需要用英文。';
  }
  
  // 重置appId，统一使用自定义提示词
  chatProcessDto.appId = 0;
  
  // 设置系统提示词
  chatProcessDto.systemMessage = `您是中华文化大师，请根据我的内容进行优化、生成相关一个中国文化相关题型，尽量做的精细，不管我问你什么、都需要您回复我一个内容相关的题型出来，并且按规则输出，除了题型之外、不要无关内容和总结。我需要的题型规则是：${promptTemplate}。${languagePrompt}`;
  
  // 设置用户提示词
  chatProcessDto.prompt = `我的中国文化内容是：${chatProcessDto.prompt}`;
  
  // 调用ChatGPT服务生成题目
  return this.chatgptService.chatProcess(
    Object.assign(
      Object.assign({}, chatProcessDto), 
      {
        cusromPrompt: true,
        dayCountType: useTotal_constant_1.UseTypeFreeStatusEnum.TOPIC_COUNT_FREE
      }
    ), 
    req, 
    res
  );
}
```

### 服务层实现 (chatgpt.service.js)

```javascript
async chatProcess(chatProcessDto, req, res) {
  // 准备请求参数
  const { prompt, systemMessage, options, cusromPrompt } = chatProcessDto;
  
  try {
    // 调用AI模型API
    const response = await this.openaiService.createChatCompletion({
      messages: [
        { role: "system", content: systemMessage },
        { role: "user", content: prompt }
      ],
      stream: true,
      model: "gpt-3.5-turbo" // 或其他模型
    });
    
    // 处理流式响应
    res.setHeader('Content-Type', 'application/json');
    
    // 创建流处理
    const stream = response.data;
    let buffer = '';
    
    stream.on('data', (chunk) => {
      buffer += chunk.toString();
      if (buffer.includes('\n')) {
        const lines = buffer.split('\n');
        buffer = lines.pop();
        
        for (const line of lines) {
          if (line.trim() === '') continue;
          if (line.includes('data: [DONE]')) continue;
          
          try {
            const data = JSON.parse(line.replace('data: ', ''));
            const content = data.choices[0].delta.content || '';
            if (content) {
              res.write(JSON.stringify({ text: content }));
              res.write('\n');
            }
          } catch (e) {
            // 处理JSON解析错误
          }
        }
      }
    });
    
    stream.on('end', () => {
      if (buffer) {
        try {
          const data = JSON.parse(buffer.replace('data: ', ''));
          const content = data.choices[0].delta.content || '';
          if (content) {
            res.write(JSON.stringify({ text: content }));
            res.write('\n');
          }
        } catch (e) {
          // 处理JSON解析错误
        }
      }
      res.end();
    });
    
    // 更新用量统计
    await this.usageService.updateUsage(req.user.id, 'topic');
    
    return true;
  } catch (error) {
    // 错误处理
    console.error('Error in chatProcess:', error);
    if (!res.headersSent) {
      res.status(500).json({ message: 'AI服务请求失败' });
    }
    return false;
  }
}
```

## 实现步骤

要实现课堂小测智能生题功能，请按照以下步骤进行：

1. **数据库准备**
   - 确保`course_question`表已创建，包含必要字段
   - 创建必要的用户权限和关联表

2. **后端实现**
   - 在`app/server/modules/chatgpt`目录下实现控制器和服务
   - 添加`chatTopic`方法处理题目生成请求
   - 实现AI服务调用和流式响应处理
   - 配置路由和依赖注入

3. **前端实现**
   - 在`app/work`目录下创建课堂小测组件
   - 实现题型选择、语言选择UI
   - 实现内容输入区域和生成按钮
   - 实现结果展示和保存功能
   - 处理流式响应更新UI

4. **集成测试**
   - 测试不同题型生成功能
   - 测试中英文切换功能
   - 测试内容保存和提取功能
   - 优化用户体验和响应速度

## 注意事项

1. **API密钥管理**
   - 确保AI服务API密钥安全存储，不要硬编码在代码中
   - 使用环境变量或配置服务管理API密钥

2. **提示词优化**
   - 定期优化系统提示词以提高生成质量
   - 收集用户反馈改进提示词模板

3. **流量控制**
   - 实现请求频率限制，防止API过度使用
   - 监控API使用量，避免超出配额

4. **错误处理**
   - 妥善处理AI服务连接失败情况
   - 为用户提供友好的错误提示

5. **内容安全**
   - 实现内容过滤，防止生成不适当内容
   - 对敏感话题进行适当处理

6. **性能优化**
   - 优化前端响应速度，提升用户体验
   - 考虑实现结果缓存，减少重复请求

7. **语言处理**
   - 针对英文输出进行额外的语法和拼写检查
   - 确保中英文答案格式一致性 